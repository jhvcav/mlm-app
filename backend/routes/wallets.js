const express = require("express");
const router = express.Router();
const Member = require("../models/Member");
const Wallet = require('../models/Wallet');
const mongoose = require("mongoose");

// ‚úÖ Ajouter un wallet √† un membre (sans cryptage)
router.post('/add-wallet', async (req, res) => {
    try {
        let { memberId, walletName, publicAddress, encryptedPassword, secretPhrase } = req.body;

        // üîç V√©rifier si tous les champs obligatoires sont fournis
        if (!memberId || !walletName || !publicAddress || !encryptedPassword || !secretPhrase) {
            return res.status(400).json({ error: "‚ùå Tous les champs sont obligatoires." });
        }

        // V√©rifier si le membre existe
        const member = await Member.findById(memberId);
        if (!member) {
            return res.status(404).json({ error: "‚ùå Membre introuvable." });
        }

        // Cr√©er le wallet avec les donn√©es en clair
        const newWallet = new Wallet({
            ownerId: memberId,
            walletName: walletName.trim(),
            publicAddress: publicAddress.trim(),
            encryptedPassword,  // Stocke le mot de passe en clair
            secretPhrase        // Stocke la phrase secr√®te en clair
        });

        await newWallet.save();

        // Ajouter le wallet √† la liste des wallets du membre
        member.wallets.push(newWallet._id);
        await member.save();

        res.status(201).json({ message: "‚úÖ Wallet ajout√© avec succ√®s !" });
    } catch (err) {
        console.error("‚ùå Erreur lors de l'ajout du wallet :", err);
        res.status(500).json({ error: error.message});
    }
});

// ‚úÖ V√©rifier un mot de passe sans cryptage
router.post('/verify-password', async (req, res) => {
    try {
        const { walletId, passwordToCheck } = req.body;

        if (!walletId || !passwordToCheck) {
            return res.status(400).json({ error: "‚ùå Wallet ID et mot de passe requis." });
        }

        const wallet = await Wallet.findById(walletId);
        if (!wallet) {
            return res.status(404).json({ error: "‚ö†Ô∏è Wallet non trouv√©." });
        }

        // Comparer directement avec la valeur stock√©e
        if (passwordToCheck !== wallet.encryptedPassword) {
            return res.status(401).json({ error: "‚ùå Mot de passe incorrect." });
        }

        res.json({ message: "‚úÖ Mot de passe valide !" });
    } catch (err) {
        console.error("‚ùå Erreur lors de la v√©rification du mot de passe :", err);
        res.status(500).json({ error: "Erreur interne du serveur." });
    }
});

// ‚úÖ V√©rifier une phrase secr√®te sans cryptage
router.post('/verify-secret', async (req, res) => {
    try {
        const { walletId, secretToCheck } = req.body;

        if (!walletId || !secretToCheck) {
            return res.status(400).json({ error: "‚ùå Wallet ID et phrase secr√®te requis." });
        }

        const wallet = await Wallet.findById(walletId);
        if (!wallet) {
            return res.status(404).json({ error: "‚ö†Ô∏è Wallet non trouv√©." });
        }

        // Comparer directement avec la valeur stock√©e
        if (secretToCheck !== wallet.secretPhrase) {
            return res.status(401).json({ error: "‚ùå Phrase secr√®te incorrecte." });
        }

        res.json({ message: "‚úÖ Phrase secr√®te valide !" });
    } catch (err) {
        console.error("‚ùå Erreur lors de la v√©rification de la phrase secr√®te :", err);
        res.status(500).json({ error: "Erreur interne du serveur." });
    }
});

// ‚úÖ R√©cup√©rer les wallets d'un membre (sans afficher le mot de passe ni la phrase secr√®te)
router.get('/member/:memberId', async (req, res) => {
    try {
        const memberId = req.params.memberId;

        // ‚úÖ V√©rifie si l'ID est valide
        if (!mongoose.Types.ObjectId.isValid(memberId)) {
            return res.status(400).json({ error: "‚ùå ID du membre invalide." });
        }

        // ‚úÖ V√©rifie si le membre existe
        const member = await Member.findById(memberId);
        if (!member) {
            return res.status(404).json({ error: "‚ùå Membre introuvable." });
        }

        // ‚úÖ Correction ici : Ajout de `new` devant `ObjectId`
        let wallets = [];
        try {
            wallets = await Wallet.find({ ownerId: new mongoose.Types.ObjectId(memberId) })
            .select("walletName publicAddress")
        } catch (walletError) {
            return res.status(500).json({ 
                error: "Erreur interne du serveur.", 
                details: walletError.message 
            });
        }

        res.json({ member, wallets });
    } catch (err) {
        res.status(500).json({ 
            error: "Erreur interne du serveur.", 
            details: err.message 
        });
    }
});

module.exports = router;